//anatomy of a simple contract
//contract that allows anyone to store a single number on the starknet blockchain.


#[starknet::interface]
trait ISimpleStorage <TContractState> {
    fn set(ref self: TContractState, x:u128);
    fn get(self: @TContractState) -> u128;
    //get function takes asnapshot of TContractState, which immediately tells us that it does not
    //modify the state
}
//inrefaces represent the blueprint of the contract.they define the funcs that the contract exposes to the outside world.
//all funcs of the trait are considered public funcs of any contract that implements this trait.
//self, is representing the contract state.
//using self, here tells us that this func. can access the state of the contract.
//ref modifier implies that self.


#[starknet::contract]
mod SimpleStorage {
    #[storage]
    struct Storage {
        stored_data:u128
    }
    //state is defined within the Storage struct, and is always initialized empty.
    #[abi(embed_v0)]//this attribute exposes the funcs defined in this implementation to the outside world.
    //incase u dont add the above attribute to the funcs will not be callable from the outside.
    //all funcs defined in ablock marked as #[abi(embed_v0)] are consequently public funcs
    impl SimpleStorage of super::ISimpleStorage<ContractState> {
        fn set(ref self: TContractState, x:u128 ){
            self.stored_data.write(x);
        }
        fn get(self: @ContractState) -> u128  {
            self.stored_data.read()//used to access the state of a contract.
        }
        //logic is defined by funcs that interact with the state.here our contracts defines and publicly 
        //exposes the funcs set and get that can be used to modify or retrieve the value of the stored.
        //variable
    }
}
//when writing the implementation of an interface, the self param in the trait mthds  must be 
//of type ContractSTate. the ContractState type is generated by the compiler, and gives access to the 
//storage variables defined in the Storage struct.additionally ContractState gives us the 
//ability to emit events. the name ContractState is not surprising as its a representation
//of the contract's state which is what we think of self in the contract interface trait.
//when self is a snapshot of ContractState, only read access is allowed,and emitting events is not possible.
//each value stored in the storage of the contract will still be stored in the history of the blockchain
